package evo

import scala.collection.mutable.MutableList



class MOSol(val f: Array[Double], val comparator: Dominance[MOSol])
  extends EvaluatedSolution with HasMultiobjectiveFitness {
  override def toString() = f.toString
  override def betterThan(other: EvaluatedSolution): Option[Boolean] = other match {
    case that: MOSol => {
      val c = comparator(this, that)
      if (c.isEmpty)
        None
      else Some(c.getOrElse(0) > 0)
    }
    case _ => None
  }
  override def fitness: Any = f
  override def objValues = f
}


class DominanceMOSol extends DominanceMinimized {
  override def apply(x: MOSol, y: MOSol): Option[Int] = 
    super.apply(x, y)
}
object MOSol {
  def apply(obj: List[Int], comparator: Dominance[MOSol]) = {
    new MOSol(obj.map(_.toDouble).toArray, comparator)
  }
}

object Sandbox {
  def main(args: Array[String]) {

    val a = MOSol(List(1, 3, 2), new DominanceMOSol)
    val b = MOSol(List(1, 3, 2), DominanceMOSol)
    val c = MOSol(List(1, 2, 2), DominanceMOSol)

    val sb = new NSGASelection[MOSol](DominanceMOSol)
    println(sb.paretoRanking(List(a, b, c)))

    val d = MOSol(List(2, 2, 1), DominanceMOSol)
    val e = MOSol(List(2, 1, 2), DominanceMOSol)

    val f = MOSol(List(2, 1, 3), DominanceMOSol)

    val pop = List(a, b, c, d, e, f)
    println(sb.paretoRanking(pop))

    println(sb(pop, 4, List()))

    println(sb(pop, 5, List()))

    println(sb(pop, 6, List()))

    val pop2 = List(a, b, c, d, e, f, f, f)
    println(sb(pop2, 6, List()))
  }
}  


/*
  // Discrete sparsity: inverse of the number of candidate solutions at a given location of Pareto front
  def sparsity(solutions: Seq[T]) ={
    val spar = solutions.groupBy( s => s.fitness ).map( p => (p._1, 1.0/p._2.length) )
    solutions.map( s => (s, spar(s.fitness)))
  }
  */
