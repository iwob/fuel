package evo

import scala.collection.mutable.MutableList



class MOSol(val f: Array[Double], val comparator: Dominance[MOSol])
  extends EvaluatedSolution with HasMultiobjectiveFitness {
  override def toString() = f.toString
  override def betterThan(other: EvaluatedSolution): Option[Boolean] = other match {
    case that: MOSol => {
      val c = comparator(this, that)
      if (c.isEmpty)
        None
      else Some(c.getOrElse(0) > 0)
    }
    case _ => None
  }
  override def fitness: Any = f
  override def objValues = f
}


class DominanceMOSol extends DominanceMinimized {
  override def apply(x: MOSol, y: MOSol): Option[Int] = 
    super.apply(x, y)
}
object MOSol {
  def apply(obj: List[Int], comparator: Dominance[MOSol]) = {
    new MOSol(obj.map(_.toDouble).toArray, comparator)
  }
}

object Sandbox {
  def main(args: Array[String]) {

    val a = MOSol(List(1, 3, 2), new DominanceMOSol)
    val b = MOSol(List(1, 3, 2), DominanceMOSol)
    val c = MOSol(List(1, 2, 2), DominanceMOSol)

    val sb = new NSGASelection[MOSol](DominanceMOSol)
    println(sb.paretoRanking(List(a, b, c)))

    val d = MOSol(List(2, 2, 1), DominanceMOSol)
    val e = MOSol(List(2, 1, 2), DominanceMOSol)

    val f = MOSol(List(2, 1, 3), DominanceMOSol)

    val pop = List(a, b, c, d, e, f)
    println(sb.paretoRanking(pop))

    println(sb(pop, 4, List()))

    println(sb(pop, 5, List()))

    println(sb(pop, 6, List()))

    val pop2 = List(a, b, c, d, e, f, f, f)
    println(sb(pop2, 6, List()))
  }
}  


/*
  // Discrete sparsity: inverse of the number of candidate solutions at a given location of Pareto front
  def sparsity(solutions: Seq[T]) ={
    val spar = solutions.groupBy( s => s.fitness ).map( p => (p._1, 1.0/p._2.length) )
    solutions.map( s => (s, spar(s.fitness)))
  }
  */
  /*
   * TODO: This other form of apply() is intended to be used with NSGA2. 
   * Because of that, it has to start with selection stage. 
   *
  def apply2(current: State[ES], previous: Seq[ES] = Seq[ES]()): Option[(State[ES], Seq[ES], ES)] = {

      val selected = selection(current.solutions, current.solutions.length, previous)

    // Evaluation of an individual may end with None, which signals infeasible solution
    var evaluated = Seq[ES]()
    var i = 0
    while( evaluated.size < current.solutions.length) {
      val parent = if( i < selected.length ) selected(i)
    	else selected( rng.nextInt(selected.length))
          val r = rng.nextDouble
          var sum: Double = 0
          val offspring = searchOperators.find(e => { sum += e._2; sum >= r }).get._1(parent)
          evaluated = evaluated ++ evalFunction(offspring)  // Note: option!
    }
      
//      offspring.map(evalFunction(_, current)).flatten
    // parallel version: val evaluated = current.solutions.par.map(evalFunction(_, current)).flatten.seq
    if (evaluated.isEmpty)  // In case no individual passed the evaluation stage
      // This is really a problem; can occur also at the first step of search. TODO: will need to move search operators to the beginning of this function. 
      return None
    else {
      println( "To select: " + current.solutions.length )

      val bestInThisGeneration = new BestSelector[ES].apply(evaluated)
      Some((new State(offspring), evaluated, bestInThisGeneration))
    }
  }
    * 
    *      offspring += (operator match {
        case op: Function3[ES,ES,ES,S] => op ( parents.next, parents.next, parents.next ) 
        case op: Function2[ES,ES,S] => op ( parents.next, parents.next ) 
        case op: Function1[ES,S] => op ( parents.next ) 
        case _ => throw new Exception("Invalid arity of search operator (>3)")
 /